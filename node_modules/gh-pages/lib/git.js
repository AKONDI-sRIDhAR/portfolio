const cp = require('child_process');
const path = require('path');
const util = require('util');
const fs = require('fs-extra');
const os = require('os');

function ProcessError(code, message) {
  const callee = arguments.callee;
  Error.apply(this, [message]);
  Error.captureStackTrace(this, callee);
  this.code = code;
  this.message = message;
  this.name = callee.name;
}
util.inherits(ProcessError, Error);

function spawn(exe, args, cwd) {
  return new Promise((resolve, reject) => {
    const child = cp.spawn(exe, args, { cwd: cwd || process.cwd() });
    const buffer = [];
    child.stderr.on('data', (chunk) => buffer.push(chunk.toString()));
    child.stdout.on('data', (chunk) => buffer.push(chunk.toString()));
    child.on('close', (code) => {
      const output = buffer.join('');
      if (code) {
        const msg = output || 'Process failed: ' + code;
        reject(new ProcessError(code, msg));
      } else {
        resolve(output);
      }
    });
  });
}

function Git(cwd, cmd) {
  this.cwd = cwd;
  this.cmd = cmd || 'git';
  this.output = '';
}

Git.prototype.exec = function (...args) {
  return spawn(this.cmd, [...args], this.cwd).then((output) => {
    this.output = output;
    return this;
  });
};

Git.prototype.init = function () {
  return this.exec('init');
};

Git.prototype.clean = function () {
  return this.exec('clean', '-f', '-d');
};

Git.prototype.reset = function (remote, branch) {
  return this.exec('reset', '--hard', remote + '/' + branch);
};

Git.prototype.fetch = function (remote) {
  return this.exec('fetch', remote);
};

Git.prototype.checkout = function (remote, branch) {
  const treeish = remote + '/' + branch;
  return this.exec('ls-remote', '--exit-code', '.', treeish).then(
    () => {
      return this.exec('checkout', branch)
        .then(() => this.clean())
        .then(() => this.reset(remote, branch));
    },
    (error) => {
      if (error instanceof ProcessError && error.code === 2) {
        return this.exec('checkout', '--orphan', branch);
      } else {
        throw error;
      }
    }
  );
};

// âœ… PATCHED rm METHOD FOR WINDOWS
Git.prototype.rm = function (files) {
  if (!Array.isArray(files)) {
    files = [files];
  }

  if (os.platform() === 'win32') {
    return separateRm(this, files);
  } else {
    return this.exec('rm', '--ignore-unmatch', '-r', '-f', '--', ...files);
  }
};

async function separateRm(thisObj, files) {
  const limitFileCount = 100;
  const fileLength = files.length;
  let loopCount = Math.ceil(fileLength / limitFileCount);
  let startIdx = 0;
  const allExecResult = [];
  let endIdx = limitFileCount;

  for (let i = 0; i < loopCount; i++) {
    if (endIdx > fileLength) {
      endIdx = fileLength;
    }
    let rmFiles = files.slice(startIdx, endIdx);
    allExecResult.push(await thisObj.exec('rm', '--ignore-unmatch', '-r', '-f', '--', ...rmFiles));
    startIdx = endIdx;
    endIdx += limitFileCount;
  }
  return allExecResult[allExecResult.length - 1];
}

Git.prototype.add = function (files) {
  if (!Array.isArray(files)) {
    files = [files];
  }
  return this.exec('add', ...files);
};

Git.prototype.commit = function (message) {
  return this.exec('diff-index', '--quiet', 'HEAD').catch(() =>
    this.exec('commit', '-m', message)
  );
};

Git.prototype.tag = function (name) {
  return this.exec('tag', name);
};

Git.prototype.push = function (remote, branch, force) {
  const args = ['push', '--tags', remote, branch];
  if (force) {
    args.push('--force');
  }
  return this.exec.apply(this, args);
};

Git.prototype.getRemoteUrl = function (remote) {
  return this.exec('config', '--get', 'remote.' + remote + '.url')
    .then((git) => {
      const repo = git.output && git.output.split(/[\n\r]/).shift();
      if (repo) {
        return repo;
      } else {
        throw new Error('Failed to get repo URL from options or current directory.');
      }
    })
    .catch(() => {
      throw new Error(
        'Failed to get remote.' +
          remote +
          '.url (task must either be run in a git repository with a configured ' +
          remote +
          ' remote or must be configured with the "repo" option).'
      );
    });
};

Git.prototype.deleteRef = function (branch) {
  return this.exec('update-ref', '-d', 'refs/heads/' + branch);
};

Git.clone = function clone(repo, dir, branch, options) {
  return fs.exists(dir).then((exists) => {
    if (exists) {
      return Promise.resolve(new Git(dir, options.git));
    } else {
      return fs.mkdirp(path.dirname(path.resolve(dir))).then(() => {
        const args = [
          'clone',
          repo,
          dir,
          '--branch',
          branch,
          '--single-branch',
          '--origin',
          options.remote,
          '--depth',
          options.depth,
        ];
        return spawn(options.git, args)
          .catch(() => {
            return spawn(options.git, ['clone', repo, dir, '--origin', options.remote]);
          })
          .then(() => new Git(dir, options.git));
      });
    }
  });
};

module.exports = Git;
